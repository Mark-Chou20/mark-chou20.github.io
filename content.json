{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"关于","date":"2021-01-20T08:49:50.157Z","updated":"2021-01-20T08:49:50.157Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"友情链接","date":"2021-01-20T08:49:50.158Z","updated":"2021-01-20T08:49:50.158Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-01-20T08:49:50.158Z","updated":"2021-01-20T08:49:50.158Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-01-20T08:49:50.159Z","updated":"2021-01-20T08:49:50.159Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"书单","date":"2021-01-20T08:49:50.157Z","updated":"2021-01-20T08:49:50.157Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-01-20T08:49:50.160Z","updated":"2021-01-20T08:49:50.160Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"springboot中的多数据源配置方案","date":"2021-01-24T06:55:00.750Z","updated":"2021-01-07T01:19:29.755Z","comments":true,"path":"2021/01/24/springboot中的多数据源配置方案/","link":"","permalink":"http://example.com/2021/01/24/springboot%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE%E6%96%B9%E6%A1%88/","excerpt":"","text":"springboot中的多数据源配置方案 多数据源可以理解为多数据库，甚至可以是多个不同类型的数据库，比如一个是MySql，一个是Oracle。随着项目的扩大，有时需要数据库的拆分或者引入另一个数据库，这时就需要配置多个数据源。 SpringBoot中使用多数据源还是比较简单的，为了演示方便，我们在MySql中创建两个数据库：ds1、ds2，并在ds1数据库中创建student表，在ds2数据库中创建teacher表。数据库脚本如下： 123456789101112131415161718192021222324252627SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS &#x3D; 0;-- ------------------------------ Table structure for student-- ----------------------------DROP TABLE IF EXISTS &#96;student&#96;;CREATE TABLE &#96;student&#96; ( &#96;id&#96; varchar(16) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL, &#96;name&#96; varchar(64) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL, &#96;class&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL, PRIMARY KEY (&#96;id&#96;) USING BTREE) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_bin ROW_FORMAT &#x3D; Dynamic;-- ------------------------------ Records of student-- ----------------------------INSERT INTO &#96;student&#96; VALUES (&#39;123456&#39;, &#39;zhangsan&#39;, &#39;北京&#39;);INSERT INTO &#96;student&#96; VALUES (&#39;123457&#39;, &#39;lisi&#39;, &#39;上海&#39;);SET FOREIGN_KEY_CHECKS &#x3D; 1; 1234567891011121314151617181920212223242526SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS &#x3D; 0;-- ------------------------------ Table structure for teacher-- ----------------------------DROP TABLE IF EXISTS &#96;teacher&#96;;CREATE TABLE &#96;teacher&#96; ( &#96;id&#96; varchar(16) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL, &#96;name&#96; varchar(32) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL, &#96;class&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL, PRIMARY KEY (&#96;id&#96;) USING BTREE) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_bin ROW_FORMAT &#x3D; Dynamic;-- ------------------------------ Records of teacher-- ----------------------------INSERT INTO &#96;teacher&#96; VALUES (&#39;0000001&#39;, &#39;wangwu&#39;, &#39;上海&#39;);SET FOREIGN_KEY_CHECKS &#x3D; 1; 基于MyBatis的多数据源实现首先创建一个MyBatis项目，项目结构如下： 这里有一点需要注意，StudentMapper接口和TeacherMapper接口是分开的，它们位于不同子目录下，这个后面会提到。 数据库连接配置既然是多数据源，数据库连接的信息就有可能存在不同，所以需要在配置文件中配置各个数据源的连接信息（这里使用了druid数据库连接池）。 1234567891011121314151617181920212223242526272829303132333435363738394041spring: datasource: ds1: #数据源1，默认数据源 url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ds1?serverTimezone&#x3D;GMT&amp;useSSL&#x3D;false&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8 username: root password: root typ: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver filters: stat maxActive: 2 initialSize: 1 maxWait: 60000 minIdle: 1 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true maxOpenPreparedStatements: 20 ds2: #数据源2 url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ds2?serverTimezone&#x3D;GMT&amp;useSSL&#x3D;false&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8 username: root password: root typ: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver filters: stat maxActive: 2 initialSize: 1 maxWait: 60000 minIdle: 1 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true maxOpenPreparedStatements: 20 注意不同的数据源要用不同的属性名区分。 重写SpringBoot的数据源配置1、数据源1的配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Configuration@MapperScan(basePackages &#x3D; &#123;&quot;com.chou.easyspringboot.multipledatasource.mapper.ds1&quot;&#125;, sqlSessionFactoryRef &#x3D; &quot;sqlSessionFactory1&quot;)public class Datasource1Configuration &#123; @Value(&quot;$&#123;mybatis.mapper-locations&#125;&quot;) private String mapperLocation; @Value(&quot;$&#123;spring.datasource.ds1.url&#125;&quot;) private String jdbcUrl; @Value(&quot;$&#123;spring.datasource.ds1.driver-class-name&#125;&quot;) private String driverClassName; @Value(&quot;$&#123;spring.datasource.ds1.username&#125;&quot;) private String username; @Value(&quot;$&#123;spring.datasource.ds1.password&#125;&quot;) private String password; @Value(&quot;$&#123;spring.datasource.ds1.initialSize&#125;&quot;) private int initialSize; @Value(&quot;$&#123;spring.datasource.ds1.minIdle&#125;&quot;) private int minIdle; @Value(&quot;$&#123;spring.datasource.ds1.maxActive&#125;&quot;) private int maxActive; @Bean(name &#x3D; &quot;dataSource1&quot;) @Primary public DataSource dataSource() &#123; DruidDataSource dataSource &#x3D; new DruidDataSource(); dataSource.setUrl(jdbcUrl); dataSource.setDriverClassName(driverClassName); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setInitialSize(initialSize); dataSource.setMinIdle(minIdle); dataSource.setMaxActive(maxActive); return dataSource; &#125; @Bean(&quot;sqlSessionFactory1&quot;) public SqlSessionFactory sqlSessionFactory(@Qualifier(&quot;dataSource1&quot;) DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean sqlSessionFactoryBean &#x3D; new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSource); sqlSessionFactoryBean.setMapperLocations( new PathMatchingResourcePatternResolver().getResources(mapperLocation)); return sqlSessionFactoryBean.getObject(); &#125; @Bean(&quot;sqlSessionTemplate1&quot;) public SqlSessionTemplate sqlSessionTemplate(@Qualifier(&quot;sqlSessionFactory1&quot;) SqlSessionFactory sqlSessionFactory) &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125; @Bean(&quot;transactionManager1&quot;) public DataSourceTransactionManager transactionManager(@Qualifier(&quot;dataSource1&quot;)DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125;&#125; 2、数据源2的配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Configuration@MapperScan(basePackages &#x3D; &#123;&quot;com.chou.easyspringboot.multipledatasource.mapper.ds2&quot;&#125;, sqlSessionFactoryRef &#x3D; &quot;sqlSessionFactory2&quot;)public class Datasource2Configuration &#123; @Value(&quot;$&#123;mybatis.mapper-locations&#125;&quot;) private String mapperLocation; @Value(&quot;$&#123;spring.datasource.ds2.url&#125;&quot;) private String jdbcUrl; @Value(&quot;$&#123;spring.datasource.ds2.driver-class-name&#125;&quot;) private String driverClassName; @Value(&quot;$&#123;spring.datasource.ds2.username&#125;&quot;) private String username; @Value(&quot;$&#123;spring.datasource.ds2.password&#125;&quot;) private String password; @Value(&quot;$&#123;spring.datasource.ds2.initialSize&#125;&quot;) private int initialSize; @Value(&quot;$&#123;spring.datasource.ds2.minIdle&#125;&quot;) private int minIdle; @Value(&quot;$&#123;spring.datasource.ds2.maxActive&#125;&quot;) private int maxActive; @Bean(name &#x3D; &quot;dataSource2&quot;) public DataSource dataSource() &#123; DruidDataSource dataSource &#x3D; new DruidDataSource(); dataSource.setUrl(jdbcUrl); dataSource.setDriverClassName(driverClassName); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setInitialSize(initialSize); dataSource.setMinIdle(minIdle); dataSource.setMaxActive(maxActive); return dataSource; &#125; @Bean(&quot;sqlSessionFactory2&quot;) public SqlSessionFactory sqlSessionFactory(@Qualifier(&quot;dataSource2&quot;) DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean sqlSessionFactoryBean &#x3D; new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSource); sqlSessionFactoryBean.setMapperLocations( new PathMatchingResourcePatternResolver().getResources(mapperLocation)); return sqlSessionFactoryBean.getObject(); &#125; @Bean(&quot;sqlSessionTemplate2&quot;) public SqlSessionTemplate sqlSessionTemplate(@Qualifier(&quot;sqlSessionFactory2&quot;) SqlSessionFactory sqlSessionFactory) &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125; @Bean(&quot;transactionManager2&quot;) public DataSourceTransactionManager transactionManager(@Qualifier(&quot;dataSource2&quot;) DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125;&#125; 这里和但数据源不同的地方在于对dataSource、sqlSessionFactory、sqlSessionTemplate、transactionManager都进行了单独的配置。另外，数据源1和数据源2主要存在两点不同： @MapperScan中的包扫描路径不一样，数据源1只扫描com.chou.easyspringboot.multipledatasource.mapper.ds1路径下的Mapper，数据源2负责com.chou.easyspringboot.multipledatasource.mapper.ds2下Mapper，所以在前面创建的时候我们要把StudentMapper和TeacherMapper分开。因为在这里已经配置了@MapperScan，所以在启动类中必须不能在存在@MapperScan注解 数据源1中多一个@Primary注解，这是告诉Spring我们使用的默认数据源，也是多数据源项目中必不可少的。 测试编写相应的Controller和Service层代码，查询所有的Student和Teacher信息，并使用postman模拟发送请求，会有如下的运行结果： 查询所有的Student 查询所有Teacher 我们连续发送两个不同的请求，都得出了想要的结果，说明MyBatis自动帮我们切换到了对应的数据源上。 基于自定义注解实现多数据源上面我们提高到数据源自动切换主要依靠MyBatis，如果项目中没有使用MyBatis该如何做呢？ 多数据源自动切换原理这里介绍一种基于自定义注解的方法实现多数据源的动态切换。SpringBoot中有一个AbstractRoutingDataSource抽象类，我们可以实现其抽象方法determineCurrentLookupKey()去指定数据源。并通过AOP编写自定义注解处理类，在sql语句执行前，切换到自定义注解中设置的数据源以实现数据源的自动切换。 数据库连接配置同上配置两个数据库连接信息。 创建数据源存放类DataSource是和线程绑在一起的，因此，我们需要一个线程安全的类来存放DataSource，在determineCurrentLookupKey()中通过该类获取数据源。 AbstractRoutingDataSource类中，DataSource以键值对的形式保存，可以使用ThreadLocal来保存key，从而实现多数据源的自动切换。 12345678910111213141516171819202122232425262728public class DataSourceContextHolder &#123; private static Logger logger &#x3D; LoggerFactory.getLogger(DataSourceContextHolder.class); &#x2F;&#x2F; 使用ThreadLocal线程安全的使用变量副本 private static final ThreadLocal&lt;String&gt; CONTEXT_HOLDER &#x3D; new ThreadLocal&lt;String&gt;(); &#x2F;** * 设置数据源 * *&#x2F; public static void setDataSource(String dataSource) &#123; logger.info(&quot;切换到数据源：&#123;&#125;&quot;, dataSource); CONTEXT_HOLDER.set(dataSource); &#125; &#x2F;** * 获取数据源 * *&#x2F; public static String getDataSource() &#123; return CONTEXT_HOLDER.get(); &#125; &#x2F;** * 清空数据源 * *&#x2F; public static void clearDataSource() &#123; CONTEXT_HOLDER.remove(); &#125;&#125; 数据源持有类定义了三个方法，分别用于数据源的设置、获取和清除。 创建数据源枚举类1234public enum DataSourceEnum &#123; PRIMARY, &#x2F;&#x2F;默认数据源 DATASOURCE1&#125; 实现 determineCurrentLookupKey 方法指定数据源123456public class DynamicDataSource extends AbstractRoutingDataSource &#123; @Override protected Object determineCurrentLookupKey() &#123; return DataSourceContextHolder.getDataSource(); &#125;&#125; 配置数据源123456789101112131415161718192021222324252627282930@Configurationpublic class DynamicDataSourceConfiguration &#123; @Bean(name &#x3D; &quot;primaryDataSource&quot;) @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.ds1&quot;) public DataSource primaryDataSource()&#123; return new DruidDataSource(); &#125; @Bean(name &#x3D; &quot;dataSource1&quot;) @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.ds2&quot;) public DataSource dataSource1()&#123; return new DruidDataSource(); &#125; @Bean(&quot;dynamicDataSource&quot;) @Primary public DataSource dynamicDataSource() &#123; DynamicDataSource dynamicDataSource &#x3D; new DynamicDataSource(); &#x2F;&#x2F;配置默认数据源 dynamicDataSource.setDefaultTargetDataSource(primaryDataSource()); &#x2F;&#x2F;配置多数据源 HashMap&lt;Object, Object&gt; dataSourceMap &#x3D; new HashMap(); dataSourceMap.put(DataSourceEnum.PRIMARY.name(),primaryDataSource()); dataSourceMap.put(DataSourceEnum.DATASOURCE1.name(),dataSource1()); dynamicDataSource.setTargetDataSources(dataSourceMap); return dynamicDataSource; &#125;&#125; 自定义注解123456@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface DataSource &#123; DataSourceEnum value() default DataSourceEnum.PRIMARY;&#125; 自定义注解指定作用于方法上并在运行期生效（可以在网上查下如何自定义注解，这里不在讲述）。 AOP拦截通过AOP在执行sql语句前拦截，并切换到自定义注解指定的数据源上。有一点需要注意，自定义数据源注解与@Transaction注解同一个方法时会先执行@Transaction，即获取数据源在切换数据源之前，所以会导致自定义注解失效，因此需要使用@Order(@Order的value越小，就越先执行)，保证该AOP在@Transactional之前执行。 1234567891011121314151617181920212223242526@Aspect@Component@Order(-1)public class DataSourceAspect &#123; @Pointcut(&quot;@annotation(com.chou.easyspringboot.multipledatasource.annotation.DataSource)&quot;) public void dataSourcePointCut() &#123; &#125; @Around(&quot;dataSourcePointCut()&quot;) public Object dataSourceArround(ProceedingJoinPoint proceed) throws Throwable &#123; MethodSignature methodSignature &#x3D; (MethodSignature) proceed.getSignature(); Method method &#x3D; methodSignature.getMethod(); DataSource dataSource &#x3D; method.getAnnotation(DataSource.class); if(dataSource !&#x3D; null) &#123; DataSourceContextHolder.setDataSource(dataSource.value().name()); &#125; try &#123; return proceed.proceed(); &#125; finally &#123; &#x2F;&#x2F; 方法执行后销毁数据源 DataSourceContextHolder.clearDataSource(); &#125; &#125;&#125; 创建启动类，编写Controller、Service层代码需要在启动类的@SpringBootApplication注解中移除DataSource自动配置类，否则会默认自动配置，而不会使用我们自定义的DataSource，并且启动会有循环依赖的错误。 12345678@SpringBootApplication(exclude &#x3D; DataSourceAutoConfiguration.class)public class EasyspringbootMultipledatasourceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EasyspringbootMultipledatasourceApplication.class, args); &#125;&#125; 测试 查询所有Student 查询所有Teacher 我们得到了正确的结果，数据源自动切换了。 项目完整代码：https://github.com/Mark-Chou20/easy-springboot","categories":[],"tags":[]},{"title":"Java8之Optional类，巧解NPE","slug":"Java8之Optional类，巧解NPE","date":"2021-01-24T06:53:11.200Z","updated":"2021-01-24T07:37:59.177Z","comments":true,"path":"2021/01/24/Java8之Optional类，巧解NPE/","link":"","permalink":"http://example.com/2021/01/24/Java8%E4%B9%8BOptional%E7%B1%BB%EF%BC%8C%E5%B7%A7%E8%A7%A3NPE/","excerpt":"","text":"NullPointerException——空指针异常是程序中常见异常之一，也是导致程序运行失败的常见异常。以前，为了防止出现null，我们常在代码中使用if…else…做防御性检查，后来Guava为了解决上述方法造成的代码污染引入了Optional类。 Java8借鉴Guava的Optional也加入了同名的Optional类，Optional类提供了很多实用的方法，借此可以避免显示的空指针判断，从而避免NullPointerException。 常见方法下面逐一讲解Optional类提供的方法。 of方法123public static &lt;T&gt; Optional&lt;T&gt; of(T value) &#123; return new Optional&lt;&gt;(value);&#125; Optional中的构造方法都是private的，外部无法使用new方式创建Optional对象，但Optional类提供三个方法用来获取Optional的实例对象。of方法是其中之一，用来创建一个包装对象值非空的Optional实例对象，若包装对象值为空则抛出NullPointerException异常。 12&#x2F;&#x2F; user若为null则会抛出NullPointerException异常Optional&lt;User&gt; optional_user &#x3D; Optional.of(user); ofNullable方法123public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) &#123; return value &#x3D;&#x3D; null ? empty() : of(value);&#125; 获取Optional实例对象的方法之一，返回一个允许包装对象值为空的Optional实例对象。ofNullable与of方法的区别就在是否允许包装对象为空。 123&#x2F;&#x2F; 可以为空，且optional_user1 &#x3D;&#x3D; optional_user2为trueOptional&lt;User&gt; optional_user1 &#x3D; Optional.ofNullable(null);Optional&lt;User&gt; optional_user2 &#x3D; Optional.ofNullable(null); empty方法12345public static&lt;T&gt; Optional&lt;T&gt; empty() &#123; @SuppressWarnings(&quot;unchecked&quot;) Optional&lt;T&gt; t &#x3D; (Optional&lt;T&gt;) EMPTY; return t;&#125; 获取Optional实例对象的方法之一，创建一个包装对象值为空的Optional实例对象。 12&#x2F;&#x2F; 返回包装对象值为空的Optional实例对象Optional&lt;User&gt; optional_user &#x3D; Optional.empty(); isPresent方法123public boolean isPresent() &#123; return value !&#x3D; null;&#125; 判断包装对象值是否为空。 12345678&#x2F;&#x2F; 这里的user不为nullOptional&lt;User&gt; optional_user1 &#x3D; Optional.ofNullable(user);Optional&lt;User&gt; optional_user2 &#x3D; Optional.ofNullable(null);&#x2F;&#x2F; 返回trueoptional_user1.isPresent();&#x2F;&#x2F; 返回falseoptional_user2.isPresent(); ifPresent方法1234public void ifPresent(Consumer&lt;? super T&gt; consumer) &#123; if (value !&#x3D; null) consumer.accept(value);&#125; 判断包装对象值是否为空，如果包装对象的值为空则调用Consumer对象的accept()方法，不为空则不调用。 1234Optional.ofNullable(user).ifPresent(() -&gt; &#123; &#x2F;&#x2F; 包装对象值为空执行的代码 ……&#125;); get方法123456public T get() &#123; if (value &#x3D;&#x3D; null) &#123; throw new NoSuchElementException(&quot;No value present&quot;); &#125; return value;&#125; 返回包装对象的值，若为空则抛出NoSuchElementException异常。 orElse方法123public T orElse(T other) &#123; return value !&#x3D; null ? value : other;&#125; 若包装对象不是null则返回包装对象的实际值，若为null则返回指定值，即返回传入的参数。 1Optional.ofNullable(user).orElse(new User(&quot;zhangsan&quot;, 20)); orElseGet方法123public T orElseGet(Supplier&lt;? extends T&gt; other) &#123; return value !&#x3D; null ? value : other.get();&#125; 作用同orElse方法，只不过orElseGet的入参是Supplier对象，当Optional包装对象为null时返回指定值，返回值由Supplier的get方法产生。 12&#x2F;&#x2F; name是一个String对象Optional.ofNullable(name).orElseGet(() -&gt; &quot;zhangsan&quot;); orElseThrow方法1234567public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X &#123; if (value !&#x3D; null) &#123; return value; &#125; else &#123; throw exceptionSupplier.get(); &#125;&#125; 作用同orElseGet类似，当包装对象不为空时返回包装对象的值，为空时返回一个Throwable异常。 filter方法1234567public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) &#123; Objects.requireNonNull(predicate); if (!isPresent()) return this; else return predicate.test(value) ? this : empty();&#125; 过滤Optional的包装对象，当包装对象满足Predicate的条件时返回该Optional实例，否则返回包装对象为null的Optional实例。 1234&#x2F;&#x2F; 过滤name为zhangsan的User，当不存在时打印提示信息Optional.ofNullable(user) .filter(u -&gt; u.getName.equals(&quot;zhangsan&quot;)) .ifPresent(() -&gt; System.out.println(&quot;There is no zhangsan&quot;)); map方法12345678public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) &#123; Objects.requireNonNull(mapper); if (!isPresent()) return empty(); else &#123; return Optional.ofNullable(mapper.apply(value)); &#125;&#125; map方法对包装对象进行函数运算（即调用Function的apply方法）后返回一个新的Optional实例对象，新Optional实例的包装对象可以时任意类型（不一定与原包装对象的类型保持一致）。 如果包装对象为null则依然返回一个包装对象为null的Optional实例，map可以无限级调用。 12&#x2F;&#x2F; 返回一个Optional&lt;String&gt;Optional.of(user).map(u -&gt; u.getName()); flatMap方法12345678public&lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; mapper) &#123; Objects.requireNonNull(mapper); if (!isPresent()) return empty(); else &#123; return Objects.requireNonNull(mapper.apply(value)); &#125;&#125; 功能同map方法，二者的区别在mapper的apply方法的返回值类型不同，map方法中的mapper返回值可以是任意类型，而flatMap中的mapper的返回值是Optional类型，map方法会自动封装返回一个Optional。 12&#x2F;&#x2F; 返回一个Optional&lt;String&gt;，作用同map的例子Optional.of(user).flatMap(u -&gt; Optional.of(u.getName())); 解决NPE在由Optional之前，我们会使用if…else…做防御性检查，以防止出现空指针异常。 123456public String getUserName(User user) &#123; if(user &#x3D;&#x3D; null) &#123; return &quot;unknown&quot;; &#125; return user.getName();&#125; 有了Optional之后，我们可以这样做了…… 1234567public String getUserName(User user) &#123; Optional&lt;User&gt; optional_user &#x3D; Optional.ofNullable(user); if(!optional_user.isPresent()) &#123; return &quot;unknown&quot;; &#125; return user.getName();&#125; 啊……这…… 显然这两种方法并无本质区别，依然都有防御性检查，依然都不够简洁。只不过第二种方法利用isPresent方法替换了显示的null判断。 正确的姿势。 123456public String getUserName(User user) &#123; &#x2F;&#x2F; 善用map方法 return Optional.ofNullable(user) .map(u -&gt; u.getName()) .orElse(&quot;unkonwn&quot;);&#125; 这个例子并不能完全展示Optional的实力，再看下面的示例。 12345678910111213141516&#x2F;*** 获取领导姓名，不使用Optional* *&#x2F;public String getBossName(User user) &#123; if(user !&#x3D; null) &#123; Company company &#x3D; user.getCompany(); if(company !&#x3D; null) &#123; Boss boss &#x3D; company.getBoss(); if(boss !&#x3D; null) &#123; return boss.getName(); &#125; &#125; &#125; return &quot;unkonwn&quot;;&#125; 优雅的姿势。 12345678910&#x2F;*** 获取领导姓名，使用Optional* *&#x2F;public String getBossName(User user) &#123; return Optional.ofNullable(user) .map(u -&gt; u.getCompany()) .map(c -&gt; c.getBoss()) .map(b -&gt; b.getName()) .orElse(&quot;unkonwn&quot;);&#125; 善用Optional会使我们的代码无比的优雅和简洁。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"Java8","slug":"Java基础/Java8","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/Java8/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"http://example.com/tags/Java8/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-01-20T08:42:39.597Z","updated":"2021-01-20T08:42:39.597Z","comments":true,"path":"2021/01/20/hello-world/","link":"","permalink":"http://example.com/2021/01/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"Java8","slug":"Java基础/Java8","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/Java8/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"http://example.com/tags/Java8/"}]}