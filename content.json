{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://www.coding-up.com","root":"/"},"pages":[{"title":"关于","date":"2021-01-25T12:37:26.078Z","updated":"2021-01-25T12:37:26.078Z","comments":false,"path":"about/index.html","permalink":"https://www.coding-up.com/about/index.html","excerpt":"","text":"12345678910111213141516171819202122232425262728293031&#123; name: &#39;Mark Chou&#39; age: &#39;90后&#39;, gender: &#39;男&#39;, profession: &#39;Java &amp; JavaWeb Developer&#39;, experience: &#39;5年&#39;, address: &#39;辽宁省大连市&#39;, education: &#39;硕士&#39;, github: &#39;http:&#x2F;&#x2F;github.com&#x2F;Mark-Chou20&#39;, blog: &#39;http:&#x2F;&#x2F;www.coding-up.com&#x2F;&#39;, wechatOfficialaccount: &#39;CoderReading&#39;, email: &#39;mark_chou20@163.com&#39;, skills: [ [&#39;Java&#39;], [&#39;Spring&#39;, &#39;SpringBoot&#39;, &#39;SpringMvc&#39;], [&#39;Mybatis&#39;, &#39;Mybatis-Plus&#39;, &#39;Mybatis-Generator&#39;], [&#39;RabitMQ&#39;, &#39;Kafaka&#39;], [&#39;MySQL&#39;, &#39;Oracle&#39;, &#39;Redis&#39;, &#39;MongoDB&#39;, &#39;Elasticsearch&#39;], [&#39;Html&#39;, &#39;Javascript&#39;, &#39;jQuery&#39;, &#39;CSS&#39;, &#39;Vue&#39;], [&#39;Microservice Architecture&#39;, &#39;Distribution&#39;], ], devTools: [ [&#39;Git&#39;], [&#39;Meaven&#39;, &#39;Gradle&#39;], [&#39;Idea&#39;, &#39;Eclipse&#39;, &#39;VS Code&#39;], [&#39;Nginx&#39;], [&#39;Navicat&#39;], ] &#125;"},{"title":"书单","date":"2021-01-25T12:37:26.045Z","updated":"2021-01-25T12:37:26.045Z","comments":false,"path":"books/index.html","permalink":"https://www.coding-up.com/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-01-25T12:37:26.033Z","updated":"2021-01-25T12:37:26.033Z","comments":false,"path":"links/index.html","permalink":"https://www.coding-up.com/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-01-25T12:37:26.069Z","updated":"2021-01-25T12:37:26.069Z","comments":false,"path":"categories/index.html","permalink":"https://www.coding-up.com/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-01-25T12:37:26.113Z","updated":"2021-01-25T12:37:26.113Z","comments":false,"path":"repository/index.html","permalink":"https://www.coding-up.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-01-25T12:37:26.063Z","updated":"2021-01-25T12:37:26.063Z","comments":false,"path":"tags/index.html","permalink":"https://www.coding-up.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Springboot起步依赖与自动配置原理","slug":"Springboot起步依赖与自动配置原理","date":"2021-02-09T08:20:46.438Z","updated":"2021-02-09T08:47:51.043Z","comments":true,"path":"2021/02/09/Springboot起步依赖与自动配置原理/","link":"","permalink":"https://www.coding-up.com/2021/02/09/Springboot%E8%B5%B7%E6%AD%A5%E4%BE%9D%E8%B5%96%E4%B8%8E%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/","excerpt":"","text":"什么是起步依赖在没有SpringBoot之前，如果要使用Spring开发一个web工程，我们需要怎么做呢？ 首先，我们需要添加Spring、SpringMVC的框架的依赖，有时还需要考虑这些依赖间的版本兼容性，我们pom.xml文件看起来往往是这样的。 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-web&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt; &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.5&lt;&#x2F;version&gt; &lt;scope&gt;provided&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; 然后，配置web.xml。 123456789101112131415161718192021222324&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt; &lt;!-- SpringMVC的前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt; &lt;!-- 设置自己定义的控制器xml文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;param-value&gt;&#x2F;WEB-INF&#x2F;my-servlet.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt; &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt; &lt;&#x2F;servlet&gt; &lt;!-- Spring MVC配置文件结束 --&gt; &lt;!-- 拦截设置 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;&#x2F;servlet-name&gt; &lt;!-- 由SpringMVC拦截所有请求 --&gt; &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt; &lt;&#x2F;servlet-mapping&gt; &lt;&#x2F;web-app&gt; 然后修改自定义的控制器xml。 1234567891011&lt;beans&gt; &lt;!-- 把标记了@Controller注解的类转换为bean --&gt; &lt;context:component-scan base-package&#x3D;&quot;com.mucfc&quot; &#x2F;&gt; &lt;!-- 启动Spring MVC的注解功能，完成请求和注解POJO的映射 --&gt; &lt;bean class&#x3D;&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot; &#x2F;&gt; &lt;!-- 对模型视图名称的解析，即在模型视图名称添加前后缀 --&gt; &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; p:prefix&#x3D;&quot;&#x2F;WEB-INF&#x2F;views&#x2F;&quot; p:suffix&#x3D;&quot;.jsp&quot;&#x2F;&gt;&lt;beans&gt; 而有了SpringBoot后我们只需要在pom.xml文件中继承SpringBoot并引入web的起步依赖，之后添加启动类即可。通过对比，SpringBoot明显简化了大量的配置，使得我们可以快速搭建一个应用。 SpringBoot提供了非常多的starter（起步依赖），这些starter预先打包好了与常用模块相关的所有jar包，并完成了自动配置。因此，起步依赖本质上是一个Maven项目对象模型，定义了对其他库的传递依赖，这些组合在一起支持某种特定功能，这就使得我们在开发时不必过多的关注框架配置，从而简化了开发过程。 使用起步依赖SpringBoot提供了近50种starter，如上述说的创建一个web工程，我们只需要早pom文件中添加spring-boot-starter-web即可（Spring提供的starter命名规范spring-boot-starter-xxx.jar，第三方提供的starter命名规范xxx-spring-boot-starter.jar），starter的命名往往表明了其能提供的功能。 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 如果依赖项没有指明版本号，SpringBoot会根据自己的版本号自动关联。如果需要指定特定的版本号，通过元素指定即可。 覆盖起步依赖引入的依赖还是以spring-boot-starter-web为例，spring-boot-starter-web传递依赖了Jackson JSON库，如果你的项目中并不会用到JSON，你可以使用maven的元素将其排除即可（不排除也不会有任何副作用），如下： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jackson-bom&lt;&#x2F;artifactId&gt; &lt;&#x2F;exclusion&gt; &lt;&#x2F;exclusions&gt;&lt;&#x2F;dependency&gt; 另外，如果你想使用另一个版本的Jackson而不是spring-boot-starter-web中自带的，你只需要在pom.xml文件中添加实际要用的依赖即可，maven会使用pom中的依赖覆盖starter引入的传递依赖。 自动配置SpringBoot的自动配置使得Spring在运行过程中可以根据不同情况决定使用哪个配置，其实现原理是利用了Spring的条件化配置，条件话配置允许配置存在与应用中，但是只有在满足某些特定条件时才会被使用。 上篇文章中我们提到过，要启动SpringBoot需要有一个@SpringBootApplication注解的启动引导类，该类除了是应用的入口，还有着配置SpringBoot的重要作用。上篇文章（《三种方法带你新建一个SpringBoot项目》）中，我们简单介绍了下@SpringBootApplication，该注解等同于同时使用@Configuration, @EnableAutoConfiguration 和 @ComponentScan默认属性的情况，而@EnableAutoConfiguration 则是自动配置的关键，看下其源码： 12345678910111213@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY &#x3D; &quot;spring.boot.enableautoconfiguration&quot;; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;;&#125; 其核心在于@Import({AutoConfigurationImportSelector.class})，熟悉Spring的都知道@Import的作用是将组件加载到Spring容器中，这里是将AutoConfigurationImportSelector添加到Spring容器中。AutoConfigurationImportSelector类中的selectImports方法会调用进getCandidateConfigurations方法，该方法的实现如下： 12345protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; List&lt;String&gt; configurations &#x3D; SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF&#x2F;spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;); return configurations;&#125; loadFactoryNames会扫描classpath下所有jar包的META-INF/spring.factories文件，将spring.factories文件中key为EnableAutoConfiguration的所有值取出，这些值就是自动配置类的全限定名，然后通过反射将这些类加载到Spring容器中。打开spring-boot-autoconfigure-2.4.1.RELEASE.jar/META-INF/spring.factories文件并找到EnableAutoConfiguration看一下（只截取前几行）： 12345678910# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\…… 那这些自动配置类是如何被启用的呢？看个简单的DispatcherServletAutoConfiguration类，分析下其源码（只截取前几行）： 123456789101112131415@AutoConfigureOrder(-2147483648)@Configuration( proxyBeanMethods &#x3D; false)@ConditionalOnWebApplication( type &#x3D; Type.SERVLET)@ConditionalOnClass(&#123;DispatcherServlet.class&#125;)@AutoConfigureAfter(&#123;ServletWebServerFactoryAutoConfiguration.class&#125;)public class DispatcherServletAutoConfiguration &#123; public static final String DEFAULT_DISPATCHER_SERVLET_BEAN_NAME &#x3D; &quot;dispatcherServlet&quot;; public static final String DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME &#x3D; &quot;dispatcherServletRegistration&quot;; public DispatcherServletAutoConfiguration() &#123; &#125; 不难看出该类也被很多注解修饰了，@Configuration表明这是一个配置类。该配置类是否被启用的关键是@ConditionalOnClass注解，在DispatcherServletAutoConfiguration中@ConditionalOnClass指定只有在DispatcherServlet类存在时该配置才会生效。 除此之外，还有好多@ConditionalOnXXX注解（如：@ConditionalOnWebApplication、@ConditionalOnBean等等），这些注解就是条件注解，只有在满足条件的情况下，配置类才会生效。 项目地址：https://github.com/Mark-Chou20/easy-springboothttps://gitee.com/java-er/easy-springboot","categories":[{"name":"ø 框架","slug":"o-框架","permalink":"https://www.coding-up.com/categories/o-%E6%A1%86%E6%9E%B6/"},{"name":"Springboot","slug":"o-框架/Springboot","permalink":"https://www.coding-up.com/categories/o-%E6%A1%86%E6%9E%B6/Springboot/"}],"tags":[{"name":"起步依赖","slug":"起步依赖","permalink":"https://www.coding-up.com/tags/%E8%B5%B7%E6%AD%A5%E4%BE%9D%E8%B5%96/"},{"name":"自动配置","slug":"自动配置","permalink":"https://www.coding-up.com/tags/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"}]},{"title":"SpringBoot中的多数据源配置方案","slug":"springboot中的多数据源配置方案","date":"2021-01-24T06:55:00.750Z","updated":"2021-02-09T08:06:35.017Z","comments":true,"path":"2021/01/24/springboot中的多数据源配置方案/","link":"","permalink":"https://www.coding-up.com/2021/01/24/springboot%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE%E6%96%B9%E6%A1%88/","excerpt":"","text":"多数据源可以理解为多数据库，甚至可以是多个不同类型的数据库，比如一个是MySql，一个是Oracle。随着项目的扩大，有时需要数据库的拆分或者引入另一个数据库，这时就需要配置多个数据源。 SpringBoot中使用多数据源还是比较简单的，为了演示方便，我们在MySql中创建两个数据库：ds1、ds2，并在ds1数据库中创建student表，在ds2数据库中创建teacher表。数据库脚本如下： 123456789101112131415161718192021222324252627SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS &#x3D; 0;-- ------------------------------ Table structure for student-- ----------------------------DROP TABLE IF EXISTS &#96;student&#96;;CREATE TABLE &#96;student&#96; ( &#96;id&#96; varchar(16) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL, &#96;name&#96; varchar(64) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL, &#96;class&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL, PRIMARY KEY (&#96;id&#96;) USING BTREE) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_bin ROW_FORMAT &#x3D; Dynamic;-- ------------------------------ Records of student-- ----------------------------INSERT INTO &#96;student&#96; VALUES (&#39;123456&#39;, &#39;zhangsan&#39;, &#39;北京&#39;);INSERT INTO &#96;student&#96; VALUES (&#39;123457&#39;, &#39;lisi&#39;, &#39;上海&#39;);SET FOREIGN_KEY_CHECKS &#x3D; 1; 1234567891011121314151617181920212223242526SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS &#x3D; 0;-- ------------------------------ Table structure for teacher-- ----------------------------DROP TABLE IF EXISTS &#96;teacher&#96;;CREATE TABLE &#96;teacher&#96; ( &#96;id&#96; varchar(16) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL, &#96;name&#96; varchar(32) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL, &#96;class&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL, PRIMARY KEY (&#96;id&#96;) USING BTREE) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_bin ROW_FORMAT &#x3D; Dynamic;-- ------------------------------ Records of teacher-- ----------------------------INSERT INTO &#96;teacher&#96; VALUES (&#39;0000001&#39;, &#39;wangwu&#39;, &#39;上海&#39;);SET FOREIGN_KEY_CHECKS &#x3D; 1; 基于MyBatis的多数据源实现首先创建一个MyBatis项目，项目结构如下： 这里有一点需要注意，StudentMapper接口和TeacherMapper接口是分开的，它们位于不同子目录下，这个后面会提到。 数据库连接配置既然是多数据源，数据库连接的信息就有可能存在不同，所以需要在配置文件中配置各个数据源的连接信息（这里使用了druid数据库连接池）。 1234567891011121314151617181920212223242526272829303132333435363738394041spring: datasource: ds1: #数据源1，默认数据源 url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ds1?serverTimezone&#x3D;GMT&amp;useSSL&#x3D;false&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8 username: root password: root typ: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver filters: stat maxActive: 2 initialSize: 1 maxWait: 60000 minIdle: 1 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true maxOpenPreparedStatements: 20 ds2: #数据源2 url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ds2?serverTimezone&#x3D;GMT&amp;useSSL&#x3D;false&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8 username: root password: root typ: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver filters: stat maxActive: 2 initialSize: 1 maxWait: 60000 minIdle: 1 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true maxOpenPreparedStatements: 20 注意不同的数据源要用不同的属性名区分。 重写SpringBoot的数据源配置1、数据源1的配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Configuration@MapperScan(basePackages &#x3D; &#123;&quot;com.chou.easyspringboot.multipledatasource.mapper.ds1&quot;&#125;, sqlSessionFactoryRef &#x3D; &quot;sqlSessionFactory1&quot;)public class Datasource1Configuration &#123; @Value(&quot;$&#123;mybatis.mapper-locations&#125;&quot;) private String mapperLocation; @Value(&quot;$&#123;spring.datasource.ds1.url&#125;&quot;) private String jdbcUrl; @Value(&quot;$&#123;spring.datasource.ds1.driver-class-name&#125;&quot;) private String driverClassName; @Value(&quot;$&#123;spring.datasource.ds1.username&#125;&quot;) private String username; @Value(&quot;$&#123;spring.datasource.ds1.password&#125;&quot;) private String password; @Value(&quot;$&#123;spring.datasource.ds1.initialSize&#125;&quot;) private int initialSize; @Value(&quot;$&#123;spring.datasource.ds1.minIdle&#125;&quot;) private int minIdle; @Value(&quot;$&#123;spring.datasource.ds1.maxActive&#125;&quot;) private int maxActive; @Bean(name &#x3D; &quot;dataSource1&quot;) @Primary public DataSource dataSource() &#123; DruidDataSource dataSource &#x3D; new DruidDataSource(); dataSource.setUrl(jdbcUrl); dataSource.setDriverClassName(driverClassName); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setInitialSize(initialSize); dataSource.setMinIdle(minIdle); dataSource.setMaxActive(maxActive); return dataSource; &#125; @Bean(&quot;sqlSessionFactory1&quot;) public SqlSessionFactory sqlSessionFactory(@Qualifier(&quot;dataSource1&quot;) DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean sqlSessionFactoryBean &#x3D; new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSource); sqlSessionFactoryBean.setMapperLocations( new PathMatchingResourcePatternResolver().getResources(mapperLocation)); return sqlSessionFactoryBean.getObject(); &#125; @Bean(&quot;sqlSessionTemplate1&quot;) public SqlSessionTemplate sqlSessionTemplate(@Qualifier(&quot;sqlSessionFactory1&quot;) SqlSessionFactory sqlSessionFactory) &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125; @Bean(&quot;transactionManager1&quot;) public DataSourceTransactionManager transactionManager(@Qualifier(&quot;dataSource1&quot;)DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125;&#125; 2、数据源2的配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Configuration@MapperScan(basePackages &#x3D; &#123;&quot;com.chou.easyspringboot.multipledatasource.mapper.ds2&quot;&#125;, sqlSessionFactoryRef &#x3D; &quot;sqlSessionFactory2&quot;)public class Datasource2Configuration &#123; @Value(&quot;$&#123;mybatis.mapper-locations&#125;&quot;) private String mapperLocation; @Value(&quot;$&#123;spring.datasource.ds2.url&#125;&quot;) private String jdbcUrl; @Value(&quot;$&#123;spring.datasource.ds2.driver-class-name&#125;&quot;) private String driverClassName; @Value(&quot;$&#123;spring.datasource.ds2.username&#125;&quot;) private String username; @Value(&quot;$&#123;spring.datasource.ds2.password&#125;&quot;) private String password; @Value(&quot;$&#123;spring.datasource.ds2.initialSize&#125;&quot;) private int initialSize; @Value(&quot;$&#123;spring.datasource.ds2.minIdle&#125;&quot;) private int minIdle; @Value(&quot;$&#123;spring.datasource.ds2.maxActive&#125;&quot;) private int maxActive; @Bean(name &#x3D; &quot;dataSource2&quot;) public DataSource dataSource() &#123; DruidDataSource dataSource &#x3D; new DruidDataSource(); dataSource.setUrl(jdbcUrl); dataSource.setDriverClassName(driverClassName); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setInitialSize(initialSize); dataSource.setMinIdle(minIdle); dataSource.setMaxActive(maxActive); return dataSource; &#125; @Bean(&quot;sqlSessionFactory2&quot;) public SqlSessionFactory sqlSessionFactory(@Qualifier(&quot;dataSource2&quot;) DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean sqlSessionFactoryBean &#x3D; new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSource); sqlSessionFactoryBean.setMapperLocations( new PathMatchingResourcePatternResolver().getResources(mapperLocation)); return sqlSessionFactoryBean.getObject(); &#125; @Bean(&quot;sqlSessionTemplate2&quot;) public SqlSessionTemplate sqlSessionTemplate(@Qualifier(&quot;sqlSessionFactory2&quot;) SqlSessionFactory sqlSessionFactory) &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125; @Bean(&quot;transactionManager2&quot;) public DataSourceTransactionManager transactionManager(@Qualifier(&quot;dataSource2&quot;) DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125;&#125; 这里和但数据源不同的地方在于对dataSource、sqlSessionFactory、sqlSessionTemplate、transactionManager都进行了单独的配置。另外，数据源1和数据源2主要存在两点不同： @MapperScan中的包扫描路径不一样，数据源1只扫描com.chou.easyspringboot.multipledatasource.mapper.ds1路径下的Mapper，数据源2负责com.chou.easyspringboot.multipledatasource.mapper.ds2下Mapper，所以在前面创建的时候我们要把StudentMapper和TeacherMapper分开。因为在这里已经配置了@MapperScan，所以在启动类中必须不能在存在@MapperScan注解 数据源1中多一个@Primary注解，这是告诉Spring我们使用的默认数据源，也是多数据源项目中必不可少的。 测试编写相应的Controller和Service层代码，查询所有的Student和Teacher信息，并使用postman模拟发送请求，会有如下的运行结果： 查询所有的Student 查询所有Teacher 我们连续发送两个不同的请求，都得出了想要的结果，说明MyBatis自动帮我们切换到了对应的数据源上。 基于自定义注解实现多数据源上面我们提高到数据源自动切换主要依靠MyBatis，如果项目中没有使用MyBatis该如何做呢？ 多数据源自动切换原理这里介绍一种基于自定义注解的方法实现多数据源的动态切换。SpringBoot中有一个AbstractRoutingDataSource抽象类，我们可以实现其抽象方法determineCurrentLookupKey()去指定数据源。并通过AOP编写自定义注解处理类，在sql语句执行前，切换到自定义注解中设置的数据源以实现数据源的自动切换。 数据库连接配置同上配置两个数据库连接信息。 创建数据源存放类DataSource是和线程绑在一起的，因此，我们需要一个线程安全的类来存放DataSource，在determineCurrentLookupKey()中通过该类获取数据源。 AbstractRoutingDataSource类中，DataSource以键值对的形式保存，可以使用ThreadLocal来保存key，从而实现多数据源的自动切换。 12345678910111213141516171819202122232425262728public class DataSourceContextHolder &#123; private static Logger logger &#x3D; LoggerFactory.getLogger(DataSourceContextHolder.class); &#x2F;&#x2F; 使用ThreadLocal线程安全的使用变量副本 private static final ThreadLocal&lt;String&gt; CONTEXT_HOLDER &#x3D; new ThreadLocal&lt;String&gt;(); &#x2F;** * 设置数据源 * *&#x2F; public static void setDataSource(String dataSource) &#123; logger.info(&quot;切换到数据源：&#123;&#125;&quot;, dataSource); CONTEXT_HOLDER.set(dataSource); &#125; &#x2F;** * 获取数据源 * *&#x2F; public static String getDataSource() &#123; return CONTEXT_HOLDER.get(); &#125; &#x2F;** * 清空数据源 * *&#x2F; public static void clearDataSource() &#123; CONTEXT_HOLDER.remove(); &#125;&#125; 数据源持有类定义了三个方法，分别用于数据源的设置、获取和清除。 创建数据源枚举类1234public enum DataSourceEnum &#123; PRIMARY, &#x2F;&#x2F;默认数据源 DATASOURCE1&#125; 实现 determineCurrentLookupKey 方法指定数据源123456public class DynamicDataSource extends AbstractRoutingDataSource &#123; @Override protected Object determineCurrentLookupKey() &#123; return DataSourceContextHolder.getDataSource(); &#125;&#125; 配置数据源123456789101112131415161718192021222324252627282930@Configurationpublic class DynamicDataSourceConfiguration &#123; @Bean(name &#x3D; &quot;primaryDataSource&quot;) @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.ds1&quot;) public DataSource primaryDataSource()&#123; return new DruidDataSource(); &#125; @Bean(name &#x3D; &quot;dataSource1&quot;) @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.ds2&quot;) public DataSource dataSource1()&#123; return new DruidDataSource(); &#125; @Bean(&quot;dynamicDataSource&quot;) @Primary public DataSource dynamicDataSource() &#123; DynamicDataSource dynamicDataSource &#x3D; new DynamicDataSource(); &#x2F;&#x2F;配置默认数据源 dynamicDataSource.setDefaultTargetDataSource(primaryDataSource()); &#x2F;&#x2F;配置多数据源 HashMap&lt;Object, Object&gt; dataSourceMap &#x3D; new HashMap(); dataSourceMap.put(DataSourceEnum.PRIMARY.name(),primaryDataSource()); dataSourceMap.put(DataSourceEnum.DATASOURCE1.name(),dataSource1()); dynamicDataSource.setTargetDataSources(dataSourceMap); return dynamicDataSource; &#125;&#125; 自定义注解123456@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface DataSource &#123; DataSourceEnum value() default DataSourceEnum.PRIMARY;&#125; 自定义注解指定作用于方法上并在运行期生效（可以在网上查下如何自定义注解，这里不在讲述）。 AOP拦截通过AOP在执行sql语句前拦截，并切换到自定义注解指定的数据源上。有一点需要注意，自定义数据源注解与@Transaction注解同一个方法时会先执行@Transaction，即获取数据源在切换数据源之前，所以会导致自定义注解失效，因此需要使用@Order(@Order的value越小，就越先执行)，保证该AOP在@Transactional之前执行。 1234567891011121314151617181920212223242526@Aspect@Component@Order(-1)public class DataSourceAspect &#123; @Pointcut(&quot;@annotation(com.chou.easyspringboot.multipledatasource.annotation.DataSource)&quot;) public void dataSourcePointCut() &#123; &#125; @Around(&quot;dataSourcePointCut()&quot;) public Object dataSourceArround(ProceedingJoinPoint proceed) throws Throwable &#123; MethodSignature methodSignature &#x3D; (MethodSignature) proceed.getSignature(); Method method &#x3D; methodSignature.getMethod(); DataSource dataSource &#x3D; method.getAnnotation(DataSource.class); if(dataSource !&#x3D; null) &#123; DataSourceContextHolder.setDataSource(dataSource.value().name()); &#125; try &#123; return proceed.proceed(); &#125; finally &#123; &#x2F;&#x2F; 方法执行后销毁数据源 DataSourceContextHolder.clearDataSource(); &#125; &#125;&#125; 创建启动类，编写Controller、Service层代码需要在启动类的@SpringBootApplication注解中移除DataSource自动配置类，否则会默认自动配置，而不会使用我们自定义的DataSource，并且启动会有循环依赖的错误。 12345678@SpringBootApplication(exclude &#x3D; DataSourceAutoConfiguration.class)public class EasyspringbootMultipledatasourceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EasyspringbootMultipledatasourceApplication.class, args); &#125;&#125; 测试 查询所有Student 查询所有Teacher 我们得到了正确的结果，数据源自动切换了。 项目完整代码：https://github.com/Mark-Chou20/easy-springboot","categories":[{"name":"ø 框架","slug":"o-框架","permalink":"https://www.coding-up.com/categories/o-%E6%A1%86%E6%9E%B6/"},{"name":"SpringBoot","slug":"o-框架/SpringBoot","permalink":"https://www.coding-up.com/categories/o-%E6%A1%86%E6%9E%B6/SpringBoot/"}],"tags":[{"name":"多数据源","slug":"多数据源","permalink":"https://www.coding-up.com/tags/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/"},{"name":"读写分离","slug":"读写分离","permalink":"https://www.coding-up.com/tags/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"}]},{"title":"Java8之Optional类，巧解NPE","slug":"Java8之Optional类，巧解NPE","date":"2021-01-24T06:53:11.200Z","updated":"2021-01-25T12:37:26.175Z","comments":true,"path":"2021/01/24/Java8之Optional类，巧解NPE/","link":"","permalink":"https://www.coding-up.com/2021/01/24/Java8%E4%B9%8BOptional%E7%B1%BB%EF%BC%8C%E5%B7%A7%E8%A7%A3NPE/","excerpt":"","text":"NullPointerException——空指针异常是程序中常见异常之一，也是导致程序运行失败的常见异常。以前，为了防止出现null，我们常在代码中使用if…else…做防御性检查，后来Guava为了解决上述方法造成的代码污染引入了Optional类。 Java8借鉴Guava的Optional也加入了同名的Optional类，Optional类提供了很多实用的方法，借此可以避免显示的空指针判断，从而避免NullPointerException。 常见方法下面逐一讲解Optional类提供的方法。 of方法123public static &lt;T&gt; Optional&lt;T&gt; of(T value) &#123; return new Optional&lt;&gt;(value);&#125; Optional中的构造方法都是private的，外部无法使用new方式创建Optional对象，但Optional类提供三个方法用来获取Optional的实例对象。of方法是其中之一，用来创建一个包装对象值非空的Optional实例对象，若包装对象值为空则抛出NullPointerException异常。 12&#x2F;&#x2F; user若为null则会抛出NullPointerException异常Optional&lt;User&gt; optional_user &#x3D; Optional.of(user); ofNullable方法123public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) &#123; return value &#x3D;&#x3D; null ? empty() : of(value);&#125; 获取Optional实例对象的方法之一，返回一个允许包装对象值为空的Optional实例对象。ofNullable与of方法的区别就在是否允许包装对象为空。 123&#x2F;&#x2F; 可以为空，且optional_user1 &#x3D;&#x3D; optional_user2为trueOptional&lt;User&gt; optional_user1 &#x3D; Optional.ofNullable(null);Optional&lt;User&gt; optional_user2 &#x3D; Optional.ofNullable(null); empty方法12345public static&lt;T&gt; Optional&lt;T&gt; empty() &#123; @SuppressWarnings(&quot;unchecked&quot;) Optional&lt;T&gt; t &#x3D; (Optional&lt;T&gt;) EMPTY; return t;&#125; 获取Optional实例对象的方法之一，创建一个包装对象值为空的Optional实例对象。 12&#x2F;&#x2F; 返回包装对象值为空的Optional实例对象Optional&lt;User&gt; optional_user &#x3D; Optional.empty(); isPresent方法123public boolean isPresent() &#123; return value !&#x3D; null;&#125; 判断包装对象值是否为空。 12345678&#x2F;&#x2F; 这里的user不为nullOptional&lt;User&gt; optional_user1 &#x3D; Optional.ofNullable(user);Optional&lt;User&gt; optional_user2 &#x3D; Optional.ofNullable(null);&#x2F;&#x2F; 返回trueoptional_user1.isPresent();&#x2F;&#x2F; 返回falseoptional_user2.isPresent(); ifPresent方法1234public void ifPresent(Consumer&lt;? super T&gt; consumer) &#123; if (value !&#x3D; null) consumer.accept(value);&#125; 判断包装对象值是否为空，如果包装对象的值为空则调用Consumer对象的accept()方法，不为空则不调用。 1234Optional.ofNullable(user).ifPresent(() -&gt; &#123; &#x2F;&#x2F; 包装对象值为空执行的代码 ……&#125;); get方法123456public T get() &#123; if (value &#x3D;&#x3D; null) &#123; throw new NoSuchElementException(&quot;No value present&quot;); &#125; return value;&#125; 返回包装对象的值，若为空则抛出NoSuchElementException异常。 orElse方法123public T orElse(T other) &#123; return value !&#x3D; null ? value : other;&#125; 若包装对象不是null则返回包装对象的实际值，若为null则返回指定值，即返回传入的参数。 1Optional.ofNullable(user).orElse(new User(&quot;zhangsan&quot;, 20)); orElseGet方法123public T orElseGet(Supplier&lt;? extends T&gt; other) &#123; return value !&#x3D; null ? value : other.get();&#125; 作用同orElse方法，只不过orElseGet的入参是Supplier对象，当Optional包装对象为null时返回指定值，返回值由Supplier的get方法产生。 12&#x2F;&#x2F; name是一个String对象Optional.ofNullable(name).orElseGet(() -&gt; &quot;zhangsan&quot;); orElseThrow方法1234567public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X &#123; if (value !&#x3D; null) &#123; return value; &#125; else &#123; throw exceptionSupplier.get(); &#125;&#125; 作用同orElseGet类似，当包装对象不为空时返回包装对象的值，为空时返回一个Throwable异常。 filter方法1234567public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) &#123; Objects.requireNonNull(predicate); if (!isPresent()) return this; else return predicate.test(value) ? this : empty();&#125; 过滤Optional的包装对象，当包装对象满足Predicate的条件时返回该Optional实例，否则返回包装对象为null的Optional实例。 1234&#x2F;&#x2F; 过滤name为zhangsan的User，当不存在时打印提示信息Optional.ofNullable(user) .filter(u -&gt; u.getName.equals(&quot;zhangsan&quot;)) .ifPresent(() -&gt; System.out.println(&quot;There is no zhangsan&quot;)); map方法12345678public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) &#123; Objects.requireNonNull(mapper); if (!isPresent()) return empty(); else &#123; return Optional.ofNullable(mapper.apply(value)); &#125;&#125; map方法对包装对象进行函数运算（即调用Function的apply方法）后返回一个新的Optional实例对象，新Optional实例的包装对象可以时任意类型（不一定与原包装对象的类型保持一致）。 如果包装对象为null则依然返回一个包装对象为null的Optional实例，map可以无限级调用。 12&#x2F;&#x2F; 返回一个Optional&lt;String&gt;Optional.of(user).map(u -&gt; u.getName()); flatMap方法12345678public&lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; mapper) &#123; Objects.requireNonNull(mapper); if (!isPresent()) return empty(); else &#123; return Objects.requireNonNull(mapper.apply(value)); &#125;&#125; 功能同map方法，二者的区别在mapper的apply方法的返回值类型不同，map方法中的mapper返回值可以是任意类型，而flatMap中的mapper的返回值是Optional类型，map方法会自动封装返回一个Optional。 12&#x2F;&#x2F; 返回一个Optional&lt;String&gt;，作用同map的例子Optional.of(user).flatMap(u -&gt; Optional.of(u.getName())); 解决NPE在由Optional之前，我们会使用if…else…做防御性检查，以防止出现空指针异常。 123456public String getUserName(User user) &#123; if(user &#x3D;&#x3D; null) &#123; return &quot;unknown&quot;; &#125; return user.getName();&#125; 有了Optional之后，我们可以这样做了…… 1234567public String getUserName(User user) &#123; Optional&lt;User&gt; optional_user &#x3D; Optional.ofNullable(user); if(!optional_user.isPresent()) &#123; return &quot;unknown&quot;; &#125; return user.getName();&#125; 啊……这…… 显然这两种方法并无本质区别，依然都有防御性检查，依然都不够简洁。只不过第二种方法利用isPresent方法替换了显示的null判断。 正确的姿势。 123456public String getUserName(User user) &#123; &#x2F;&#x2F; 善用map方法 return Optional.ofNullable(user) .map(u -&gt; u.getName()) .orElse(&quot;unkonwn&quot;);&#125; 这个例子并不能完全展示Optional的实力，再看下面的示例。 12345678910111213141516&#x2F;*** 获取领导姓名，不使用Optional* *&#x2F;public String getBossName(User user) &#123; if(user !&#x3D; null) &#123; Company company &#x3D; user.getCompany(); if(company !&#x3D; null) &#123; Boss boss &#x3D; company.getBoss(); if(boss !&#x3D; null) &#123; return boss.getName(); &#125; &#125; &#125; return &quot;unkonwn&quot;;&#125; 优雅的姿势。 12345678910&#x2F;*** 获取领导姓名，使用Optional* *&#x2F;public String getBossName(User user) &#123; return Optional.ofNullable(user) .map(u -&gt; u.getCompany()) .map(c -&gt; c.getBoss()) .map(b -&gt; b.getName()) .orElse(&quot;unkonwn&quot;);&#125; 善用Optional会使我们的代码无比的优雅和简洁。","categories":[{"name":"ø Java基础","slug":"o-Java基础","permalink":"https://www.coding-up.com/categories/o-Java%E5%9F%BA%E7%A1%80/"},{"name":"Java8","slug":"o-Java基础/Java8","permalink":"https://www.coding-up.com/categories/o-Java%E5%9F%BA%E7%A1%80/Java8/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"https://www.coding-up.com/tags/Java8/"},{"name":"Optional","slug":"Optional","permalink":"https://www.coding-up.com/tags/Optional/"},{"name":"NullPointerException","slug":"NullPointerException","permalink":"https://www.coding-up.com/tags/NullPointerException/"}]}],"categories":[{"name":"ø 框架","slug":"o-框架","permalink":"https://www.coding-up.com/categories/o-%E6%A1%86%E6%9E%B6/"},{"name":"Springboot","slug":"o-框架/Springboot","permalink":"https://www.coding-up.com/categories/o-%E6%A1%86%E6%9E%B6/Springboot/"},{"name":"SpringBoot","slug":"o-框架/SpringBoot","permalink":"https://www.coding-up.com/categories/o-%E6%A1%86%E6%9E%B6/SpringBoot/"},{"name":"ø Java基础","slug":"o-Java基础","permalink":"https://www.coding-up.com/categories/o-Java%E5%9F%BA%E7%A1%80/"},{"name":"Java8","slug":"o-Java基础/Java8","permalink":"https://www.coding-up.com/categories/o-Java%E5%9F%BA%E7%A1%80/Java8/"}],"tags":[{"name":"起步依赖","slug":"起步依赖","permalink":"https://www.coding-up.com/tags/%E8%B5%B7%E6%AD%A5%E4%BE%9D%E8%B5%96/"},{"name":"自动配置","slug":"自动配置","permalink":"https://www.coding-up.com/tags/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"},{"name":"多数据源","slug":"多数据源","permalink":"https://www.coding-up.com/tags/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/"},{"name":"读写分离","slug":"读写分离","permalink":"https://www.coding-up.com/tags/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"},{"name":"Java8","slug":"Java8","permalink":"https://www.coding-up.com/tags/Java8/"},{"name":"Optional","slug":"Optional","permalink":"https://www.coding-up.com/tags/Optional/"},{"name":"NullPointerException","slug":"NullPointerException","permalink":"https://www.coding-up.com/tags/NullPointerException/"}]}